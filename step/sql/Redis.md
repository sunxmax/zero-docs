# Redis

`Redis` 全称为：`Remote Dictionary Server`（远程数据服务），是一种基于键值对（`key-value`）的NoSQL数据库。

`Redis` 速度快的主要原因：

* 完全基于内存操作
* C 语⾔实现，优化过的数据结构
* 基于⾮阻塞的 IO 多路复⽤机制
* 使⽤单线程，避免了线程切换和竞态产生的消耗

::: details I/O 多路复用

`Redis` 早期为单线程，`Redis 6.0`后启用多线程，但是多线程是用多线程来处理数据的读写和协议解析，`Redis` 执行命令还是单线程的。

> 因为 `Redis` 是基于内存的操作，`CPU` 成为 `Redis` 的瓶颈的情况很少见，`Redis` 的瓶颈最有可能是内存的大小或者网络限制。
>
> 使⽤多线程能提升IO读写的效率，从⽽整体提⾼Redis的性能。

:::

::: details 分区

分区是分割数据到多个 `Redis` 实例的处理过程，因此每个实例只保存 `key` 的一个子集。

**分区的优势**

- 通过利用多台计算机内存的和值，允许我们构造更大的数据库。

- 通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。

**分区的劣势**

- 涉及多个 key 的操作通常是不被支持的。举例来说，当两个 set 映射到不同的 redis 实例上时，你就不能对这两个set执行交集操作。
- 涉及多个 key 的 redis 事务不能使用。
- 当使用分区时，数据处理较为复杂，比如你需要处理多个 rdb/aof 文件，并且从多个实例和主机备份持久化文件。
- 增加或删除容量也比较复杂。redis 集群大多数支持在运行时增加、删除节点的透明数据平衡的能力，但是类似于客户端分区、代理等其他系统则不支持这项特性。然而，一种叫做 presharding 的技术对此是有帮助的。
:::

## 特点

**高性能**

`Redis` 会将所有数据都存放在内存中，因此具有高性能的读写能力。

**原子性**

`Redis` 的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。

**持久化**

`Redis` 可以将内存的数据利用快照和日志的形式保存到硬盘上，支持 `RDB`，`AOF` 等持久化方式。

**附加功能**

`Redis` 提供了**键过期**、**发布订阅**、**事务**、**流水线**、**Lua脚本**等附加功能。
  
## 数据结构

> `Redis` 所有的 `key`（键）都是字符串。
>
> `Redis` 中的 `value` 支持 `string`（字符串）、`hash`（哈希）、 `list`（列表）、`set`（集合）、`zset/sort set`（有序集合）、`Bitmaps`（位图）、 `HyperLogLog`、`GEO`（地理信息定位）等多种数据结构

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17d01f95f18e4bf395e1c5f40bd0ba23~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

**key**

```shell
> keys *
1) "key-list"
2) "key-hash"
3) "key-string"
```

**String**

```shell
> set key-string "hello world"
"OK"

> get key-string
"hello world"
```

**Hash**

```shell
> HMSET key-hash field1 apple field2 orange field3 banana
"OK"

> HGETALL key-hash
1) "field1"
2) "apple"
3) "field2"
4) "orange"
5) "field3"
6) "banana"

> HGET key-hash field1
"apple"

> HDEL key-hash field3
(integer) 1
```

**List**

```shell
> LPUSH key-list element1
(integer) 1

> LPUSH key-list element2
(integer) 2

> RPUSH key-list element3
(integer) 3

> lrange key-list 0 10
1) "element2"
2) "element1"
3) "element3"
```

**Set**

```shell
> sadd key-set one two three
(integer) 3

> smembers key-set
1) "three"
2) "two"
3) "one"
```

**ZSet**

`zset` 即 `Sort Set`

```shell
> ZADD key-zset 0 one 0 two 0 three
(integer) 3

> ZRANGEBYSCORE key-zset 0 100
1) "one"
2) "three"
3) "two"
```

## 持久化

持久化方式：**RDB持久化**、**AOF持久化**、**混合持久化**

**RDB持久化**

> RDB⽂件是⼀个压缩的⼆进制⽂件，通过它可以还原某个时刻数据库的状态。由于RDB⽂件是保存在硬盘上的，所以即使Redis崩溃或者退出，只要RDB⽂件存在，就可以⽤它来恢复还原数据库的状态。

**RDB持久化**是把当前进程数据生成**快照**保存到硬盘的过程，触发RDB持久化过程分为**手动触发**和**自动触发**。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7878881b559d43ce8423843a1d4f813b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

- 手动触发两种方式

  - `save`命令：阻塞当前 `Redis` 服务器，直到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。
  - `bgsave`命令：`Redis` 进程执行 `fork` 操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。

- 自动触发

  * 使用 `save` 相关配置，如 `save m n` 。表示 m 秒内数据集存在 n 次修改时，自动触发 `bgsave`。
  * 如果从节点执行全量复制操作，主节点自动执行 `bgsave`生成RDB文件并发送给从节点。
  * 执行 `debug reload` 命令重新加载 `Redis` 时，也会自动触发 `save` 操作
  * 默认情况下执行 `shutdown` 命令时，如果没有开启AOF持久化功能则自动执行 `bgsave`。

优点：

* 只有一个紧凑的二进制文件 `dump.rdb`，非常适合备份、全量复制的场景。
* 容灾性好，可以把RDB文件拷贝道远程机器或者文件系统，用于容灾恢复。
* 恢复速度快，RDB恢复数据的速度远远快于AOF的方式

缺点：

* 实时性低，RDB 是间隔一段时间进行持久化，没法做到实时持久化/秒级持久化。如果在这一间隔事件发生故障，数据会丢失。
* 存在兼容问题，Redis演进过程存在多个格式的RDB版本，存在老版本Redis无法兼容新版本RDB的问题。

**AOF持久化**

**AOF `append only file`** 以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ffb590b618f48c38de466279c5ea0bf~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

AOF的工作流程操作：命令写入 （append）、文件同步（sync）、文件重写（rewrite）、重启加载 （load） 流程如下：
1. 所有的写入命令会追加到aof_buf（缓冲区）中。
2. AOF缓冲区根据对应的策略向硬盘做同步操作。
3. 随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。
4. 当Redis服务器重启时，可以加载AOF文件进行数据恢复。

优点

* 实时性好，AOF持久化可以配置 `appendfsync:always`，每进行一次命令操作就记录到 aof 文件中一次。
* 通过 `append` 模式写文件，即使中途服务器宕机，可以通过 `redis-check-aof` 工具解决数据一致性问题。

缺点

* `AOF` 文件比 `RDB` 文件大，且恢复速度慢。
* 数据集大的时候，比 `RDB` 启动效率低。

**混合持久化**

> 重启 Redis 时，我们很少使用 RDB 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 RDB 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。
>
> Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化。
>
> 将 `RDB` 文件的内容和增量的 `AOF` 日志文件存在一起。这里的 `AOF` 日志不再是全量的日志，而是 **自持久化开始到持久化结束** 的这段时间发生的增量 `AOF` 日志，通常这部分 `AOF` 日志很小：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81c23f6e65c143ce889519136dd46295~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

在 `Redis` 重启的时候，可以先加载 `RDB` 的内容，然后再重放增量 `AOF` 日志就可以完全替代之前的 `AOF` 全量文件重放，重启效率因此大幅得到提升。

**使用**

* 混合持久化：`redis` 重启时优先载入 `AOF` 文件恢复原始数据因为 `AOF` 文件比 `RDB` 文件 保存的数据更完整。`Redis 4.0` 开启混合持久化
* RDB持久化：可以接受短时间内地数据丢失可采用该种方式。
* AOF持久化：使用很多，但是 `AOF` 文件较大，恢复时间较长，数据集较完整。
* 都不使用：如果数据不需要持久化或只需要再程序运行时使用，可以不适用持久化。

**持久化回滚**

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5cc20579aa14cde9afbbceaab5125a1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

Redis 启动时加载数据的流程：

1. AOF持久化开启且存在AOF文件时，优先加载AOF文件。
2. AOF关闭或者AOF文件不存在时，加载RDB文件。
3. 加载AOF/RDB文件成功后，Redis启动成功。
4. AOF/RDB文件存在错误时，Redis启动失败并打印错误信息。

## 高可用

`Redis` 保证高可用主要有三种方式：主从、哨兵、集群。

> 主从复制是基石，进化过程 主从 > 哨兵 > 集群

### 主从复制

主从复制，是指将一台 `Redis` 服务器的数据，复制到其他的 `Redis` 服务器。前者称为 **主节点**(master)，后者称为 **从节点**(slave)。

数据的复制是 **单向** 的，只能由主节点到从节点。`Redis` 主从复制支持 **主从同步** 和 **从从同步** 两种，后者是 `Redis` 后续版本新增的功能，以减轻主节点的同步负担。

**主从复制主要的作用**：

* 数据冗余： 主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。
* 故障恢复： 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复 (实际上是一种服务的冗余)。
* 负载均衡： 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 （即写 `Redis` 数据时应用连接主节点，读 `Redis` 数据时应用连接从节点），分担服务器负载。尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 `Redis` 服务器的并发量。
* 高可用基石： 除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是 `Redis` 高可用的基础。

**常见的主从**

1. 一主一从结构
2. 一主多从结构（星形拓扑结构）
3. 树状主从结构（树状拓扑结构）

### 主从复制原理

1. 保存主节点（master）：信息这一步只是保存主节点信息，保存主节点的ip和port。
2. 主从建立连接：从节点（slave）发现新的主节点后，会尝试和主节点建立网络连接。
3. 发送ping命令：连接建立成功后从节点发送ping请求进行首次通信，主要是检测主从之间网络套接字是否可用、主节点当前是否可接受处理命令。
4. 权限验证：如果主节点要求密码验证，从节点必须正确的密码才能通过验证。
5. 同步数据集：主从复制连接正常通信后，主节点会把持有的数据全部发送给从节点。
6. 命令持续复制：接下来主节点会持续地把写命令发送给从节点，保证主从数据一致性。

### 主从复制方式

**全量复制**

> 一般用于初次复制场景，Redis早期支持的复制功能只有全量复制，它会把主节点全部数据一次性发送给从节点，当数据量较大时，会对主从节点和网络造成很大的开销。

1. 发送 `psync` 命令进行数据同步，由于是第一次进行复制，从节点没有复制偏移量和主节点的运行ID，所以发送 `psync-1`。
2. 主节点根据`psync-1`解析出当前为全量复制，回复`+FULLRESYNC`响应。
3. 从节点接收主节点的响应数据保存运行ID和偏移量offset
4. 主节点执行`bgsave`保存RDB文件到本地
5. 主节点发送RDB文件给从节点，从节点把接收的RDB文件保存在本地并直接作为从节点的数据文件
6. 对于从节点开始接收RDB快照到接收完成期间，主节点仍然响应读写命令，因此主节点会把这期间写命令数据保存在复制客户端缓冲区内，当从节点加载完RDB文件后，主节点再把缓冲区内的数据发送给从节点，保证主从之间数据一致性。
7. 从节点接收完主节点传送来的全部数据后会清空自身旧数据
8. 从节点清空数据后开始加载RDB文件
9. 从节点成功加载完RDB后，如果当前节点开启了AOF持久化功能，它会立刻做`bgrewriteaof`操作，为了保证全量复制后AOF持久化文件立刻可用。

**部分复制**

> 部分复制主要是Redis针对全量复制的过高开销做出的一种优化措施，使用`psync{runId}{offset}`命令实现。
> 当从节点（slave）正在复制主节点 （master）时，如果出现网络闪断或者命令丢失等异常情况时，从节点会向 主节点要求补发丢失的命令数据，如果主节点的复制积压缓冲区内存在这部分数据则直接发送给从节点，这样就可以保持主从节点复制的一致性。

1. 当主从节点之间网络出现中断时，如果超过repl-timeout时间，主节点会认为从节点故障并中断复制连接
2. 主从连接中断期间主节点依然响应命令，但因复制连接中断命令无法发送给从节点，不过主节点内部存在的复制积压缓冲区，依然可以保存最近一段时间的写命令数据，默认最大缓存1MB。
3. 当主从节点网络恢复后，从节点会再次连上主节点
4. 当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和主节点的运行ID。因此会把它们当作psync参数发送给主节点，要求进行部分复制操作。
5. 主节点接到`psync`命令后首先核对参数runId是否与自身一致，如果一 致，说明之前复制的是当前主节点；之后根据参数offset在自身复制积压缓冲区查找，如果偏移量之后的数据存在缓冲区中，则对从节点发送+CONTINUE响应，表示可以进行部分复制。
6. 主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。

### 主从复制存在问题

主从复制虽好，但也存在一些问题：

* 一旦主节点出现故障，需要手动将一个从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令其他从节点去复制新的主节点，整个过程都需要人工干预。
* 主节点的写能力受到单机的限制。
* 主节点的存储能力受到单机的限制。

### 哨兵机制

> `Redis Sentinel` 即 `Redis` 哨兵，在 `Redis 2.8` 版本开始引入。哨兵的核心功能是**主节点**的**自动故障转移**。


### 集群

## 缓存问题

### 缓存击穿

### 缓存穿透

### 缓存雪崩

## 应用

### 缓存

缓存是 `redis` 最常见的应用场景。

得益于 `redis` 的高性能的读写能力。而且 `redis` 内部支持事务在使用过程中能有效地保证数据的一致性。

**两种使用方式**

* 方式一：读取前，先去读Redis，如果没有数据，读取数据库，将数据拉入 `Redis`

> **优点**：
>
> 实施起来简单
>
> **缺点**：
>
> 缓存击穿问题（数据库没有就需要命中的数据，导致Redis一直没有数据，而一直命中数据库。）
>
> 数据的实时性相对会差一点

* 方式二：插入数据时，同时写入 `Redis`。

> 数据实时性强，但是开发时不便于统一处理。

::: tips
当然，两种方式根据实际情况来适用。如：方案一适用于对于数据实时性要求不是特别高的场景。方案二适用于字典表、数据量不大的数据存储。
:::

### 计数器

`redis` 天然支持计数功能，`incrby` 命令可以实现原子性的递增。

> 可以用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。

### 消息队列

`Redis` 提供了发布订阅功能和阻塞队列的功能，可以满足一般消息队列功能。

### 分布式锁

这个主要利用 `redis` 的 `setnx` 命令进行，`setnx`（set if not exists）就是如果不存在则成功设置缓存同时返回 1，否则返回 0。

> 这个特性在很多后台中都有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先通过 `setnx` 设置一个 `lock`，如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。
>
> 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。
>
> 在分布式锁的场景中，主要用在比如秒杀系统等。

> **项目中应用**
>
> 排行榜：Redis提供了列表和有序集合数据结构，合理地使用这些数据结构可以很方便地构建各种排行榜系统。
> 
> 社交网络：赞/踩、粉丝、共同好友/喜好、推送、下拉刷新。
> 
> Token存储：用户登录成功之后，使用Redis存储Token
> 
> 登录失败次数计数：使用Redis计数，登录失败超过一定次数，锁定账号
> 
> 限时业务：使用 `expire` 命令设置一个键的生存时间。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。
> 
> 延时操作：使用 `Keyspace Notifications` 功能，允许客户订阅 `Pub/Sub` 频道，以便以某种方式接收影响 `Redis` 数据集的事件。如：订单生成后我们占用了库存，监听器监听key的实效,10分钟后去检验用户是否真正购买，如果没有购买将该单据设置无效，同时还原库存。
> 
> 地址缓存：对省市区数据的缓存
> 
> 分布式锁：分布式环境下登录、注册等操作加分布式锁

## 实战

```angular2html
docker run --name some-redis -d redis

```

## 常用工具

**桌面客户端**

[`RedisInsight` 官方出品](https://redis.com/redis-enterprise/redis-insight/)

## 问答

### Redis Sentinel（哨兵）了解吗？

> 主从复制存在一个问题，没法完成自动故障转移。所以我们需要一个方案来完成自动故障转移，它就是 `Redis Sentinel`（哨兵）。

**由两部分组成**：

* 哨兵节点： 哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的 `Redis` 节点，不存储数据，对数据节点进行监控。
* 数据节点： 主节点和从节点都是数据节点。

在复制的基础上，哨兵实现了**自动化的故障恢复**功能，下面是官方对于哨兵功能的描述：

1. 监控（Monitoring）： 哨兵会不断地检查主节点和从节点是否运作正常。
2. 自动故障转移（Automatic failover）： 当 **主节点** 不能正常工作时，哨兵会开始 自动故障转移操作，它会将失效主节点的其中一个 从节点升级为新的主节点，并让其他从节点改为复制新的主节点。
3. 配置提供者（Configuration provider）： 客户端在初始化时，通过连接哨兵来获得当前 `Redis` 服务的主节点地址。
4. 通知（Notification）： 哨兵可以将故障转移的结果发送给客户端。

其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移。而配置提供者和通知功能，则需要在与客户端的交互中才能体现。

### Redis Sentinel（哨兵）实现原理知道吗？

哨兵模式是通过哨兵节点完成对数据节点的监控、下线、故障转移。

**定时监控**
Redis Sentinel通过三个定时监控任务完成对各个节点发现和监控：

每隔10秒，每个Sentinel节点会向主节点和从节点发送info命令获取最新的拓扑结构
每隔2秒，每个Sentinel节点会向Redis数据节点的__sentinel__：hello 频道上发送该Sentinel节点对于主节点的判断以及当前Sentinel节点的信息
每隔1秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测，来确认这些节点当前是否可达


**主观下线和客观下线**

主观下线就是哨兵节点认为某个节点有问题，客观下线就是超过一定数量的哨兵节点认为主节点有问题。

* 主观下线

每个Sentinel节点会每隔1秒对主节点、从节点、其他Sentinel节点发送ping命令做心跳检测，当这些节点超过 down-after-milliseconds没有进行有效回复，Sentinel节点就会对该节点做失败判定，这个行为叫做主观下线。


* 客观下线

当Sentinel主观下线的节点是主节点时，该Sentinel节点会通过sentinel is- master-down-by-addr命令向其他Sentinel节点询问对主节点的判断，当超过 quorum个数，Sentinel节点认为主节点确实有问题，这时该Sentinel节点会做出客观下线的决定

**领导者Sentinel节点选举**

Sentinel节点之间会做一个领导者选举的工作，选出一个Sentinel节点作为领导者进行故障转移的工作。Redis使用了Raft算法实现领导者选举。


**故障转移**
领导者选举出的Sentinel节点负责故障转移，过程如下：

1. 在从节点列表中选出一个节点作为新的主节点，这一步是相对复杂一些的一步
2. Sentinel领导者节点会对第一步选出来的从节点执行slaveof no one命令让其成为主节点
3. Sentinel领导者节点会向剩余的从节点发送命令，让它们成为新主节点的从节点
4. Sentinel节点集合会将原来的主节点更新为从节点，并保持着对其关注，当其恢复后命令它去复制新的主节点

### 领导者Sentinel节点选举了解吗？

Redis使用了Raft算法实 现领导者选举，大致流程如下：


1. 每个在线的Sentinel节点都有资格成为领导者，当它确认主节点主观 下线时候，会向其他Sentinel节点发送sentinel is-master-down-by-addr命令， 要求将自己设置为领导者。
2. 收到命令的Sentinel节点，如果没有同意过其他Sentinel节点的sentinel is-master-down-by-addr命令，将同意该请求，否则拒绝。
3. 如果该Sentinel节点发现自己的票数已经大于等于max（quorum， num（sentinels）/2+1），那么它将成为领导者。
4. 如果此过程没有选举出领导者，将进入下一次选举。


### Redis 集群了解吗？

前面说到了主从存在高可用和分布式的问题，哨兵解决了高可用的问题，而集群就是终极方案，一举解决高可用和分布式问题。

数据分区： 数据分区 (或称数据分片) 是集群最核心的功能。集群将数据分散到多个节点，一方面 突破了 Redis 单机内存大小的限制，存储容量大大增加；另一方面 每个主节点都可以对外提供读服务和写服务，大大提高了集群的响应能力。

高可用： 集群支持主从复制和主节点的 自动故障转移 （与哨兵类似），当任一节点发生故障时，集群仍然可以对外提供服务。

### 集群中数据如何分区？

### 能说说Redis集群的原理吗？

### 说说集群的伸缩？

### 什么是缓存击穿、缓存穿透、缓存雪崩？

缓存击穿：一个并发访问量比较大的key在某个时间过期，导致所有的请求直接打在DB上。

缓存穿透：查询缓存和数据库中都不存在的数据，这样每次请求直接打到数据库，就好像缓存不存在一样。

缓存雪崩：某⼀时刻发⽣⼤规模的缓存失效的情况，例如缓存服务宕机、大量key在同一时间过期，这样的后果就是⼤量的请求进来直接打到DB上，可能导致整个系统的崩溃，称为雪崩。

### 能说说布隆过滤器吗？

### 如何保证缓存和数据库数据的⼀致性？




